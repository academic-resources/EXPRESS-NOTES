<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="uk" xml:lang="uk">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>Використання проміжних обробників Express</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
  </head>
  <body>
    <header id="title-block-header">
      <h1 class="title">Використання проміжних обробників Express</h1>
    </header>
    <h1 id="використання-проміжних-обробників">
      Використання проміжних обробників
    </h1>
    <p>
      Express is a routing and middleware web framework that has minimal
      functionality of its own: An Express application is essentially a series
      of middleware function calls.
    </p>
    <p>
      <em>Middleware</em> functions are functions that have access to the
      <a href="/%7B%7B%20page.lang%20%7D%7D/4x/api.html#req">request object</a>
      (<code>req</code>), the
      <a href="/%7B%7B%20page.lang%20%7D%7D/4x/api.html#res">response object</a>
      (<code>res</code>), and the next middleware function in the application’s
      request-response cycle. The next middleware function is commonly denoted
      by a variable named <code>next</code>.
    </p>
    <p>Middleware functions can perform the following tasks:</p>
    <ul>
      <li>Execute any code.</li>
      <li>Make changes to the request and the response objects.</li>
      <li>End the request-response cycle.</li>
      <li>Call the next middleware function in the stack.</li>
    </ul>
    <p>
      If the current middleware function does not end the request-response
      cycle, it must call <code>next()</code> to pass control to the next
      middleware function. Otherwise, the request will be left hanging.
    </p>
    <p>An Express application can use the following types of middleware:</p>
    <ul>
      <li>
        <a href="#middleware.application">Application-level middleware</a>
      </li>
      <li><a href="#middleware.router">Router-level middleware</a></li>
      <li>
        <a href="#middleware.error-handling">Error-handling middleware</a>
      </li>
      <li><a href="#middleware.built-in">Built-in middleware</a></li>
      <li><a href="#middleware.third-party">Third-party middleware</a></li>
    </ul>
    <p>
      You can load application-level and router-level middleware with an
      optional mount path. You can also load a series of middleware functions
      together, which creates a sub-stack of the middleware system at a mount
      point.
    </p>
    <h2 id="middleware.application">Application-level middleware</h2>
    <p>
      Bind application-level middleware to an instance of the
      <a href="/%7B%7B%20page.lang%20%7D%7D/4x/api.html#app">app object</a> by
      using the <code>app.use()</code> and <code>app.METHOD()</code> functions,
      where <code>METHOD</code> is the HTTP method of the request that the
      middleware function handles (such as GET, PUT, or POST) in lowercase.
    </p>
    <p>
      This example shows a middleware function with no mount path. The function
      is executed every time the app receives a request.
    </p>
    <pre><code class="language-javascript" translate="no">
var app = express();

app.use(function (req, res, next) {
  console.log('Time:', Date.now());
  next();
});
</code></pre>
    <p>
      This example shows a middleware function mounted on the
      <code>/user/:id</code> path. The function is executed for any type of HTTP
      request on the <code>/user/:id</code> path.
    </p>
    <pre><code class="language-javascript" translate="no">
app.use('/user/:id', function (req, res, next) {
  console.log('Request Type:', req.method);
  next();
});
</code></pre>
    <p>
      This example shows a route and its handler function (middleware system).
      The function handles GET requests to the <code>/user/:id</code> path.
    </p>
    <pre><code class="language-javascript" translate="no">
app.get('/user/:id', function (req, res, next) {
  res.send('USER');
});
</code></pre>
    <p>
      Here is an example of loading a series of middleware functions at a mount
      point, with a mount path. It illustrates a middleware sub-stack that
      prints request info for any type of HTTP request to the
      <code>/user/:id</code> path.
    </p>
    <pre><code class="language-javascript" translate="no">
app.use('/user/:id', function(req, res, next) {
  console.log('Request URL:', req.originalUrl);
  next();
}, function (req, res, next) {
  console.log('Request Type:', req.method);
  next();
});
</code></pre>
    <p>
      Route handlers enable you to define multiple routes for a path. The
      example below defines two routes for GET requests to the
      <code>/user/:id</code> path. The second route will not cause any problems,
      but it will never get called because the first route ends the
      request-response cycle.
    </p>
    <p>
      This example shows a middleware sub-stack that handles GET requests to the
      <code>/user/:id</code> path.
    </p>
    <pre><code class="language-javascript" translate="no">
app.get('/user/:id', function (req, res, next) {
  console.log('ID:', req.params.id);
  next();
}, function (req, res, next) {
  res.send('User Info');
});

// handler for the /user/:id path, which prints the user ID
app.get('/user/:id', function (req, res, next) {
  res.end(req.params.id);
});
</code></pre>
    <p>
      To skip the rest of the middleware functions from a router middleware
      stack, call <code>next('route')</code> to pass control to the next route.
      <strong>NOTE</strong>: <code>next('route')</code> will work only in
      middleware functions that were loaded by using the
      <code>app.METHOD()</code> or <code>router.METHOD()</code> functions.
    </p>
    <p>
      This example shows a middleware sub-stack that handles GET requests to the
      <code>/user/:id</code> path.
    </p>
    <pre><code class="language-javascript" translate="no">
app.get('/user/:id', function (req, res, next) {
  // if the user ID is 0, skip to the next route
  if (req.params.id == 0) next('route');
  // otherwise pass the control to the next middleware function in this stack
  else next(); //
}, function (req, res, next) {
  // render a regular page
  res.render('regular');
});

// handler for the /user/:id path, which renders a special page
app.get('/user/:id', function (req, res, next) {
  res.render('special');
});
</code></pre>
    <h2 id="middleware.router">Router-level middleware</h2>
    <p>
      Router-level middleware works in the same way as application-level
      middleware, except it is bound to an instance of
      <code>express.Router()</code>.
    </p>
    <pre><code class="language-javascript" translate="no">
var router = express.Router();
</code></pre>
    <p>
      Load router-level middleware by using the <code>router.use()</code> and
      <code>router.METHOD()</code> functions.
    </p>
    <p>
      The following example code replicates the middleware system that is shown
      above for application-level middleware, by using router-level middleware:
    </p>
    <pre><code class="language-javascript" translate="no">
var app = express();
var router = express.Router();

// a middleware function with no mount path. This code is executed for every request to the router
router.use(function (req, res, next) {
  console.log('Time:', Date.now());
  next();
});

// a middleware sub-stack shows request info for any type of HTTP request to the /user/:id path
router.use('/user/:id', function(req, res, next) {
  console.log('Request URL:', req.originalUrl);
  next();
}, function (req, res, next) {
  console.log('Request Type:', req.method);
  next();
});

// a middleware sub-stack that handles GET requests to the /user/:id path
router.get('/user/:id', function (req, res, next) {
  // if the user ID is 0, skip to the next router
  if (req.params.id == 0) next('route');
  // otherwise pass control to the next middleware function in this stack
  else next(); //
}, function (req, res, next) {
  // render a regular page
  res.render('regular');
});

// handler for the /user/:id path, which renders a special page
router.get('/user/:id', function (req, res, next) {
  console.log(req.params.id);
  res.render('special');
});

// mount the router on the app
app.use('/', router);
</code></pre>
    <h2 id="middleware.error-handling">Error-handling middleware</h2>
    <div class="doc-box doc-notice" data-markdown="1">
      <p>
        Error-handling middleware always takes <em>four</em> arguments. You must
        provide four arguments to identify it as an error-handling middleware
        function. Even if you don’t need to use the <code>next</code> object,
        you must specify it to maintain the signature. Otherwise, the
        <code>next</code> object will be interpreted as regular middleware and
        will fail to handle errors.
      </p>
    </div>
    <p>
      Define error-handling middleware functions in the same way as other
      middleware functions, except with four arguments instead of three,
      specifically with the signature <code>(err, req, res, next)</code>):
    </p>
    <pre><code class="language-javascript" translate="no">
app.use(function(err, req, res, next) {
  console.error(err.stack);
  res.status(500).send('Something broke!');
});
</code></pre>
    <p>
      For details about error-handling middleware, see:
      <a href="/%7B%7B%20page.lang%20%7D%7D/guide/error-handling.html"
        >Error handling</a
      >.
    </p>
    <h2 id="middleware.built-in">Built-in middleware</h2>
    <p>
      Starting with version 4.x, Express no longer depends on
      <a href="https://github.com/senchalabs/connect">Connect</a>. With the
      exception of <code>express.static</code>, all of the middleware functions
      that were previously included with Express’ are now in separate modules.
      Please view
      <a href="https://github.com/senchalabs/connect#middleware"
        >the list of middleware functions</a
      >.
    </p>
    <p>
      The only built-in middleware function in Express is
      <code>express.static</code>. This function is based on
      <a href="https://github.com/expressjs/serve-static">serve-static</a>, and
      is responsible for serving static assets such as HTML files, images, and
      so on.
    </p>
    The function signature is:
    <pre><code class="language-javascript" translate="no">
express.static(root, [options])
</code></pre>
    <p>
      The <code>root</code> argument specifies the root directory from which to
      serve static assets.
    </p>
    <p>
      For information on the <code>options</code> argument and more details on
      this middleware function, see
      <a href="/en/4x/api.html#express.static">express.static</a>.
    </p>
    <p>
      Here is an example of using the <code>express.static</code> middleware
      function with an elaborate options object:
    </p>
    <pre><code class="language-javascript" translate="no">
var options = {
  dotfiles: 'ignore',
  etag: false,
  extensions: ['htm', 'html'],
  index: false,
  maxAge: '1d',
  redirect: false,
  setHeaders: function (res, path, stat) {
    res.set('x-timestamp', Date.now());
  }
}

app.use(express.static('public', options));
</code></pre>
    <p>You can have more than one static directory per app:</p>
    <pre><code class="language-javascript" translate="no">
app.use(express.static('public'));
app.use(express.static('uploads'));
app.use(express.static('files'));
</code></pre>
    <p>
      For more details about the <code>serve-static</code> function and its
      options, see:
      <a href="https://github.com/expressjs/serve-static">serve-static</a>
      documentation.
    </p>
    <h2 id="middleware.third-party">Third-party middleware</h2>
    <p>Use third-party middleware to add functionality to Express apps.</p>
    <p>
      Install the Node.js module for the required functionality, then load it in
      your app at the application level or at the router level.
    </p>
    <p>
      The following example illustrates installing and loading the
      cookie-parsing middleware function <code>cookie-parser</code>.
    </p>
    <pre><code class="language-sh" translate="no">
$ npm install cookie-parser
</code></pre>
    <pre><code class="language-javascript" translate="no">
var express = require('express');
var app = express();
var cookieParser = require('cookie-parser');

// load the cookie-parsing middleware
app.use(cookieParser());
</code></pre>
    <p>
      For a partial list of third-party middleware functions that are commonly
      used with Express, see:
      <a href="../resources/middleware.html">Third-party middleware</a>.
    </p>
  </body>
</html>
