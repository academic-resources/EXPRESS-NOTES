<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Ecriture de middleware utilisable dans les applications Express</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Ecriture de middleware utilisable dans les applications Express</h1>
</header>
<h1 id="ecriture-de-middleware-utilisable-dans-les-applications-express">Ecriture de middleware utilisable dans les applications Express</h1>
<h2>
Présentation
</h2>
<p>Les fonctions de <em>middleware</em> sont des fonctions qui peuvent accéder à l’<a href="/%7B%7B%20page.lang%20%7D%7D/4x/api.html#req">objet Request</a> (<code>req</code>), l’<a href="/%7B%7B%20page.lang%20%7D%7D/4x/api.html#res">objet response</a> (<code>res</code>) et à la fonction middleware suivant dans le cycle demande-réponse de l’application. La fonction middleware suivant est couramment désignée par une variable nommée <code>next</code>.</p>
<p>Les fonctions middleware effectuent les tâches suivantes :</p>
<ul>
<li>Exécuter tout type de code.</li>
<li>Apporter des modifications aux objets de demande et de réponse.</li>
<li>Terminer le cycle de demande-réponse.</li>
<li>Appeler le middleware suivant dans la pile.</li>
</ul>
<p>Si la fonction middleware en cours ne termine pas le cycle de demande-réponse, elle doit appeler la fonction <code>next()</code> pour transmettre le contrôle à la fonction middleware suivant. Sinon, la demande restera bloquée.</p>
<p>L’exemple suivant montre les éléments d’un appel de fonction middleware:</p>
<table style="padding: 0; border: 0; width: 960px; margin-bottom: 10px;">
<tr>
<td style="margin: 0; padding: 0px; border: 0; width: 410px;">
<img src="/images/express-mw.png" style="margin: 0px; padding: 0px; width: 410px; height: 308px;" />
</td>
<td style="margin: 0; padding: 0 0 0 5px; border: 0; width: 550px;">
<div id="callout1" class="callout">
Méthode HTTP à laquelle la fonction middleware s’applique.
</div>
<div id="callout2" class="callout">
Chemin (route) auquel la fonction middleware s’applique.
</div>
<div id="callout3" class="callout">
Fonction de middleware.
</div>
<div id="callout4" class="callout">
Argument de rappel à la fonction middleware, appelée “next” par convention.
</div>
<div id="callout5" class="callout">
Argument de <a href="../4x/api.html#res">réponse</a> HTTP à la fonction middleware, appelé “res” par convention.
</div>
<div id="callout6" class="callout">
Argument de <a href="../4x/api.html#req">demande</a> HTTP à la fonction middleware, appelé “req” par convention.
</div>
</td>
</tr>
</table>
<!--
<pre>
<code class="language-javascript" translate="no">
var express = require('express');
var app = express();
app.get('/', function(req, res, next) {
    next();
});
</code>
</pre>

* <code>app.get</code>: Méthode HTTP à laquelle la fonction middleware s'applique.

* <code>'/'</code>: Chemin (route) auquel la fonction middleware s'applique.

* <code>function</code>: Fonction de middleware.

* <code>req</code>: Argument de <a href="../4x/api.html#req">demande</a> HTTP à la fonction middleware, appelé "req" par convention.

* <code>res</code>: Argument de <a href="../4x/api.html#res">réponse</a> HTTP à la fonction middleware, appelé "res" par convention.

* <code>next</code>: Argument de rappel à la fonction middleware, appelée "next" par convention.
-->
<p>Voici un exemple d’une application Express “Hello World” simple, pour laquelle vous allez définir deux fonctions middleware :</p>
<pre>
<code class="language-javascript" translate="no">
var express = require('express');
var app = express();

app.get('/', function (req, res) {
  res.send('Hello World!');
});

app.listen(3000);
</code>
</pre>
<h2>
Développement
</h2>
<p>Voici un exemple simple de fonction middleware appelée “myLogger”. Cette fonction imprime simplement “LOGGED” lorsqu’une demande traverse l’application. La fonction middleware est affectée à une variable nommée <code>myLogger</code>.</p>
<pre>
<code class="language-javascript" translate="no">
var myLogger = function (req, res, next) {
  console.log('LOGGED');
  next();
};
</code>
</pre>
<div class="doc-box doc-notice" data-markdown="1">
<p>Notez l’appel ci-dessus de la fonction <code>next()</code>, qui appelle la fonction middleware suivant dans l’application. La fonction <code>next()</code> ne fait pas partie du Node.js ou de l’API Express, mais c’est le troisième argument qui est transmis à la fonction middleware. La fonction <code>next()</code> peut porter n’importe quel nom, mais par convention elle est toujours appelée “next”. Pour éviter toute confusion, il est préférable de respecter cette convention.</p>
</div>
<p>Pour charger la fonction middleware, appelez <code>app.use()</code> en spécifiant la fonction middleware. Par exemple, le code suivant charge la fonction middleware <code>myLogger</code> avant la route au chemin racine (/).</p>
<pre>
<code class="language-javascript" translate="no">
var express = require('express');
var app = express();

var myLogger = function (req, res, next) {
  console.log('LOGGED');
  next();
};

app.use(myLogger);

app.get('/', function (req, res) {
  res.send('Hello World!');
});

app.listen(3000);
</code>
</pre>
<p>Chaque fois que l’application reçoit une demande, elle imprime le message “LOGGED” sur le terminal.</p>
<p>L’ordre de chargement des middleware est important : les fonctions middleware chargées en premier sont également exécutées en premier.</p>
<p>Si <code>myLogger</code> est chargé après la route au chemin racine, la demande ne l’atteindra jamais et l’application n’imprimera pas “LOGGED”, car le gestionnaire de route du chemin racine interrompra le cycle de demande-réponse.</p>
<p>La fonction middleware <code>myLogger</code> imprime simplement un message, puis traite la demande à la fonction middleware suivant dans la pile en appelant la fonction <code>next()</code>.</p>
<p>L’exemple suivant ajoute une propriété appelée <code>requestTime</code> à l’objet Request. Nous nommerons cette fonction middleware “requestTime”.</p>
<pre>
<code class="language-javascript" translate="no">
var requestTime = function (req, res, next) {
  req.requestTime = Date.now();
  next();
};
</code>
</pre>
<p>L’application utilise désormais la fonction middleware <code>requestTime</code>. De plus, la fonction callback de la route du chemin racine utilise la propriété que la fonction middleware ajoute à <code>req</code> (l’objet Request).</p>
<pre>
<code class="language-javascript" translate="no">
var express = require('express');
var app = express();

var requestTime = function (req, res, next) {
  req.requestTime = Date.now();
  next();
};

app.use(requestTime);

app.get('/', function (req, res) {
  var responseText = 'Hello World!<br>';
  responseText += '<small>Requested at: ' + req.requestTime + '</small>';
  res.send(responseText);
});

app.listen(3000);
</code>
</pre>
<p>Si vous effectuez une demande à la racine de l’application, cette dernière affiche maintenant l’horodatage de la demande dans le navigateur.</p>
<p>Puisque vous avez accès à l’objet Request, à l’objet Response, à la fonction middleware suivant dans la pile et à l’API Node.js complète, le champ des possibles avec les fonctions middleware est infini.</p>
<p>Pour plus d’informations sur les middleware Express, voir <a href="/%7B%7B%20page.lang%20%7D%7D/guide/using-middleware.html">Utilisation de middleware Express</a>.</p>
</body>
</html>
