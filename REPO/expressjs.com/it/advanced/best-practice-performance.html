<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="it" xml:lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Best Practice sulle prestazioni utilizzando Express in fase di produzione</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Best Practice sulle prestazioni utilizzando Express in fase di produzione</h1>
</header>
<h1 id="best-practice-sulla-produzione-prestazioni-e-affidabilità">Best practice sulla produzione: prestazioni e affidabilità</h1>
<h2 id="panoramica">Panoramica</h2>
<p>In questo articolo vengono descritte le best practice sulle prestazioni e sull’affidabilità per le applicazioni Express implementate per la produzione.</p>
<p>Questo argomento entra nel mondo di “devops”, coprendo sia le operazioni che lo sviluppo tradizionale. Di conseguenza, le informazioni sono divise in due parti:</p>
<ul>
<li><a href="#code">Operazioni da effettuare nel codice</a> (la parte dello sviluppo).</li>
<li><a href="#env">Operazioni da effettuare nell’ambiente / configurazione</a> (la parte delle operazioni).</li>
</ul>
<p><a name="code"></a></p>
<h2 id="operazioni-da-effettuare-nel-codice">Operazioni da effettuare nel codice</h2>
<p>Di seguito sono elencate alcune operazioni che è possibile effettuare nel codice per migliorare le prestazioni dell’applicazione:</p>
<ul>
<li>Utilizzare la compressione gzip</li>
<li>Non utilizzare funzioni sincrone</li>
<li>Utilizzare il middleware per servire file statici</li>
<li>Effettuare correttamente la registrazione</li>
<li>Gestire in modo appropriato le eccezioni</li>
</ul>
<h3 id="utilizzare-la-compressione-gzip">Utilizzare la compressione gzip</h3>
<p>La compressione gzip è in grado di ridurre notevolmente la dimensione del contenuto della risposta e di conseguenza aumentare la velocità di un’applicazione web. Utilizzare il middleware di <a href="https://www.npmjs.com/package/compression">compressione</a> per la compressione gzip nell’applicazione Express. Ad esempio:</p>
<pre>
<code class="language-javascript" translate="no">
var compression = require('compression');
var express = require('express');
var app = express();
app.use(compression());
</code>
</pre>
<p>Per un sito web ad elevato traffico nella produzione, il miglior modo per utilizzare la compressione è quello di implementarla ad un livello di proxy inverso (consultare <a href="#proxy">Utilizzare un proxy inverso</a>). In questo caso, non è necessario utilizzare il middleware di compressione. Per dettagli su come abilitare la compressione gzip in Nginx, consultare <a href="http://nginx.org/en/docs/http/ngx_http_gzip_module.html">Modulo ngx_http_gzip_module</a> nella documentazione Nginx.</p>
<h3 id="non-utilizzare-funzioni-sincrone">Non utilizzare funzioni sincrone</h3>
<p>I metodi e le funzioni sincrone ostacolano il processo di esecuzione finché non restituiscono un risultato. Una chiamata singola a una funzione sincrona potrebbe restituire un risultato in pochi microsecondi o millisecondi, tuttavia in siti web ad elevato traffico, queste chiamate aggiungono e riducono le prestazioni di un’applicazione. Evitarne l’utilizzo in produzione.</p>
<p>Poiché Node e molti moduli forniscono versioni sicrone e asincrone delle relative funzioni, utilizzare sempre la versione asincrona nella produzione. L’unico caso in cui l’utilizzo di una funzione sincrona è giustificato, è allo startup iniziale.</p>
<p>Se si sta utilizzando Node.js 4.0+ o io.js 2.1.0+, è possibile utilizzare il flag della riga di comando <code>--trace-sync-io</code> per stampare un avviso e un’analisi dello stack ogniqualvolta che un’applicazione utilizza una API sincrona. Naturalmente, non si consiglia di utilizzarlo nella produzione, ma solo per assicurare che il codice sia pronto per la produzione. Consultare l’<a href="https://nodejs.org/en/blog/weekly-updates/weekly-update.2015-05-22/#2-1-0">aggiornamento settimanale per io.js 2.1.0</a> per ulteriori informazioni.</p>
<h3 id="utilizzare-il-middleware-per-servire-file-statici">Utilizzare il middleware per servire file statici</h3>
<p>Nello sviluppo, è possibile utilizzare <a href="/%7B%7B%20page.lang%20%7D%7D/4x/api.html#res.sendFile">res.sendFile()</a> per servire i file statici. Ma non effettuare questa operazione in fase di produzione, poiché questa funzione deve effettuare un processo di lettura dal file system per ciascuna richiesta file, quindi si verificherà una latenza importante e si andrà a influenzare le prestazioni dell’applicazione. Notare che <code>res.sendFile()</code> <em>non</em> viene implementato con la chiamata di sistema <a href="http://linux.die.net/man/2/sendfile">sendfile</a>, che lo renderebbe molto più efficiente.</p>
<p>Al contrario, utilizzare il middleware <a href="https://www.npmjs.com/package/serve-static">serve-static</a> (o qualcosa di equivalente), ottimizzato per servire i file per le applicazioni Express.</p>
<p>Un’altra opzione potrebbe essere quella di utilizzare un proxy inverso per servire file statici; consultare <a href="#proxy">Utilizzare un proxy inverso</a> per ulteriori informazioni.</p>
<h3 id="effettuare-correttamente-la-registrazione">Effettuare correttamente la registrazione</h3>
<p>Solitamente, esistono due motivi per effettuare la registrazione dall’applicazione: per il debug e la registrazione dell’attività dell’applicazione (sostanzialmente, qualsiasi altra cosa). L’utilizzo di <code>console.log()</code> o <code>console.err()</code> per stampare i messaggi di log sul terminale, è un’operazione comune nello sviluppo. Ma <a href="https://nodejs.org/api/console.html#console_console_1">queste funzioni sono sincrone</a> quando la destinazione è un terminale o un file, pertanto non sono adatte per la produzione, a meno che non si indirizzi l’output a un altro programma.</p>
<h4 id="per-il-debug">Per il debug</h4>
<p>Se si sta effettuando la registrazione per motivi di debug, allora invece di utilizzare <code>console.log()</code>, utilizzare un modulo di debug speciale quale <a href="https://www.npmjs.com/package/debug">debug</a>. Questo modulo consente di utilizzare la variabile di ambiente DEBUG per controllare quali messaggi di debug vengono inviati a <code>console.err()</code>, se presenti. Per fare in modo che l’applicazione resti strettamente asincrona, è necessario instradare <code>console.err()</code> a un altro programma. Però a questo punto, non andrai ad effettuare il debug in fase di produzione giusto?</p>
<h4 id="per-lattività-dellapplicazione">Per l’attività dell’applicazione</h4>
<p>Se si sta registrando l’attività dell’applicazione (ad esempio, si sta tenendo traccia del traffico e delle chiamate API), invece di utilizzare <code>console.log()</code>, utilizzare una libreria di registrazione quale <a href="https://www.npmjs.com/package/winston">Winston</a> o <a href="https://www.npmjs.com/package/bunyan">Bunyan</a>. Per un confronto dettagliato di queste due librerie, consultare il post del blog di StrongLoop <a href="https://strongloop.com/strongblog/compare-node-js-logging-winston-bunyan/">Comparing Winston and Bunyan Node.js Logging</a>.</p>
<p><a name="exceptions"></a></p>
<h3 id="gestire-in-modo-appropriato-le-eccezioni">Gestire in modo appropriato le eccezioni</h3>
<p>Le applicazioni Node danno origine a errori quando riscontrano eccezioni non rilevate. Se tali eccezioni non vengono gestite o se non si effettuano operazioni appropriate, l’applicazione Express si arresterà in modo anomalo. Seguendo i consigli descritti in <a href="#restart">Riavvio automatico dell’applicazione</a>, sarà possibile recuperare l’applicazione dopo un arresto anomalo. Fortunatamente, le applicazioni Express solitamente hanno tempi di avvio molto brevi. Tuttavia, per prima cosa è necessario evitare che si verifichino arresti anomali, e per effettuare ciò, è necessario gestire in modo appropriato le eccezioni.</p>
<p>Per essere sicuri di gestire al meglio tutte le eccezioni, utilizzare le seguenti tecniche:</p>
<ul>
<li><a href="#try-catch">Utilizzare try-catch</a></li>
<li><a href="#promises">Utilizzare promises</a></li>
</ul>
<p>Prima di leggere questi argomenti, è necessario avere una conoscenza base della gestione degli errori di Node/Express: utilizzo di error-first callback e diffusione degli errori al middleware. Node utilizza la convenzione “error-first callback” per restituire gli errori da funzioni asincrone, dove il primo parametro per la funzione callback è l’oggetto dell’errore, seguito dai dati nei parametri successivi. Per indicare un errore, indicare null come primo parametro. La funzione callback deve seguire in modo corrispondente la convenzione error-first callback per gestire l’errore in modo significativo. In Express, il miglior modo è quello di utilizzare la funzione next() per diffondere gli errori attraverso la catena middleware.</p>
<p>Per ulteriori informazioni sulle nozioni di base della gestione degli errori, consultare:</p>
<ul>
<li><a href="https://www.joyent.com/developers/node/design/errors">Gestione degli errori in Node.js</a></li>
<li><a href="https://strongloop.com/strongblog/robust-node-applications-error-handling/">Come creare applicazioni Node solide: Gestione degli errori</a> (blog di StrongLoop)</li>
</ul>
<h4 id="cosa-non-fare">Cosa non fare</h4>
<p>Una cosa da <em>non</em> fare è quella di stare in ascolto per un evento <code>uncaughtException</code>, emesso quando un’eccezione si verifica ed è costante nel loop degli eventi. Se si aggiunge un programma di ascolto dell’evento per <code>uncaughtException</code> si cambierà il funzionamento predefinito del processo che sta riscontrando un’eccezione; il processo continuerà ad operare malgrado l’eccezione. Questo potrebbe risultare un ottimo modo per prevenire un arresto anomalo dell’applicazione, ma continuare ad utilizzare un’applicazione dopo che si è verificata un’eccezione non rilevata è pericoloso e non è consigliato, poiché lo stato del processo diventa non affidabile e non prevedibile.</p>
<p>Inoltre, l’utilizzo di <code>uncaughtException</code> è ufficialmente riconosciuto come <a href="https://nodejs.org/api/process.html#process_event_uncaughtexception">non conforme</a> ed esiste una <a href="https://github.com/nodejs/node-v0.x-archive/issues/2582">proposta</a> per la relativa rimozione dal core. Quindi continuare a visualizzare un evento <code>uncaughtException</code> non è un buon segno. Ecco perché consigliamo di usufruire di più processi e supervisori: l’arresto anomalo e il riavvio sono spesso il modo più affidabile per ripristinare una situazione dopo un errore.</p>
<p>Inoltre, non si consiglia di utilizzare l’opzione <a href="https://nodejs.org/api/domain.html">domini</a>. Solitamente non risolve il problema ed è considerato un modulo obsoleto.</p>
<p><a name="try-catch"></a></p>
<h4 id="utilizzare-try-catch">Utilizzare try-catch</h4>
<p>Try-catch è un linguaggio JavaScript che è possibile utilizzare per rilevare eccezioni in codice sincrono. Ad esempio, utilizzare try-catch, per gestire errori di analisi JSON come mostrato di seguito.</p>
<p>Utilizzare uno strumento come <a href="http://jshint.com/">JSHint</a> o <a href="http://www.jslint.com/">JSLint</a> come supporto nel rilevamento di eccezioni implicite quali <a href="http://www.jshint.com/docs/options/#undef">errori di riferimento su variabili non definite</a>.</p>
<p>Di seguito viene riportato un esempio di utilizzo di try-catch per la gestione di un’eccezione che dà origine a un arresto anomalo del processo. Questa funzione middleware accetta un parametro del campo query denominato “params” che è un oggetto JSON.</p>
<pre>
<code class="language-javascript" translate="no">
app.get('/search', function (req, res) {
  // Simulating async operation
  setImmediate(function () {
    var jsonStr = req.query.params;
    try {
      var jsonObj = JSON.parse(jsonStr);
      res.send('Success');
    } catch (e) {
      res.status(400).send('Invalid JSON string');
    }
  });
});
</code>
</pre>
<p>Tuttavia, try-catch funziona solo per il codice sincrono. Poiché la piattaforma Node è principalmente asincrona (nello specifico in un ambiente di produzione), try-catch non sarà in grado di rilevare molte eccezioni.</p>
<p><a name="promises"></a></p>
<h4 id="utilizzare-promises">Utilizzare promises</h4>
<p>Promises gestirà qualsiasi eccezione (sia implicita che esplicita) in blocchi di codice asincrono che utilizzano <code>then()</code>. Aggiungere <code>.catch(next)</code> alla fine della catena promise. Ad esempio:</p>
<pre>
<code class="language-javascript" translate="no">
app.get('/', function (req, res, next) {
  // do some sync stuff
  queryDb()
    .then(function (data) {
      // handle data
      return makeCsv(data)
    })
    .then(function (csv) {
      // handle csv
    })
    .catch(next);
});

app.use(function (err, req, res, next) {
  // handle error
});
</code>
</pre>
<p>Ora, tutti gli errori asincroni e sincroni vengono inoltrati al middleware degli errori.</p>
<p>Tuttavia, esistono due punti a cui prestare attenzione:</p>
<ol type="1">
<li>Tutto il codice asincrono deve restituire promises (ad eccezione di emettitori). Se una libreria particolare non restituire promises, convertire l’oggetto base utilizzando una funzione di supporto come <a href="http://bluebirdjs.com/docs/api/promise.promisifyall.html">Bluebird.promisifyAll()</a>.</li>
<li>Emettitori evento (come flussi) possono ancora dare origine ad eccezioni non rilevate. Quindi, assicurarsi di gestire l’evento di errore in modo appropriato, ad esempio:</li>
</ol>
<pre>
<code class="language-javascript" translate="no">
app.get('/', wrap(async (req, res, next) => {
  let company = await getCompanyById(req.query.id)
  let stream = getLogoStreamById(company.id)
  stream.on('error', next).pipe(res)
}))
</code>
</pre>
<p>Per ulteriori informazioni sulla gestione degli errori mediante l’utilizzo di promises, consultare:</p>
<ul>
<li><a href="https://strongloop.com/strongblog/async-error-handling-expressjs-es7-promises-generators/">Asynchronous Error Handling in Express with Promises, Generators and ES7</a></li>
<li><a href="https://strongloop.com/strongblog/promises-in-node-js-with-q-an-alternative-to-callbacks/">Promises in Node.js with Q – An Alternative to Callbacks</a></li>
</ul>
<p><a name="env"></a></p>
<h2 id="operazioni-da-effettuare-nellambiente-configurazione">Operazioni da effettuare nell’ambiente / configurazione</h2>
<p>Di seguito sono elencate alcune operazioni che è possibile effettuare nell’ambiente del sistema per migliorare le prestazioni dell’applicazione:</p>
<ul>
<li>Impostare NODE_ENV su “produzione”</li>
<li>Verificare che l’applicazione sia in grado di riavviarsi automaticamente</li>
<li>Eseguire l’applicazione in un cluster</li>
<li>Memorizzare in cache i risultati della richiesta</li>
<li>Utilizzare un servizio di bilanciamento del carico</li>
<li>Utilizzare un proxy inverso</li>
</ul>
<h3 id="impostare-node_env-su-produzione">Impostare NODE_ENV su “produzione”</h3>
<p>La variabile di ambiente NODE_ENV indica l’ambiente in cui è in esecuzione un’applicazione (solitamente, sviluppo o applicazione). Una delle cose più semplici da fare per migliorare le prestazioni, è impostare NODE_ENV su “produzione.”</p>
<p>L’impostazione di NODE_ENV su “produzione” consente ad Express di:</p>
<ul>
<li>Memorizzare in cache i template di visualizzazione.</li>
<li>Memorizzare in cache i file CSS generati da stensioni CSS.</li>
<li>Generare meno messaggi di errore ridondanti.</li>
</ul>
<p><a href="http://apmblog.dynatrace.com/2015/07/22/the-drastic-effects-of-omitting-node_env-in-your-express-js-applications/">I test hanno confermato</a> che seguendo queste indicazioni è possibile migliorare le prestazioni dell’applicazione di tre volte!</p>
<p>Se si ha la necessità di scrivere codice specifico dell’ambiente, è possibile selezionare il valore di NODE_ENV con <code>process.env.NODE_ENV</code>. Notare che la selezione del valore di qualsiasi variabile di ambiente influisce sulle prestazioni in modo negativo, quindi questa operazione deve essere effettuata con moderazione.</p>
<p>Nello sviluppo, solitamente si impostano le variabili di ambiente nella shell interattiva, ad esempio utilizzando <code>export</code> o il file <code>.bash_profile</code>. Ma solitamente non si consiglia di effettuare questa operazione su un server di produzione; al contrario, utilizzare il sistema init del sistema operativo (systemd o Upstart). La sezione successiva fornisce ulteriori dettagli sull’utilizzo in generale del sistema init, però anche impostare NODE_ENV è molto importante per le prestazioni (ed è facile da fare), evidenziato di seguito.</p>
<p>Con Upstart, utilizzare la parola chiave <code>env</code> nel file job. Ad esempio:</p>
<pre>
<code class="language-sh" translate="no">
# /etc/init/env.conf
 env NODE_ENV=production
</code>
</pre>
<p>Per ulteriori informazioni, consultare <a href="http://upstart.ubuntu.com/cookbook/#environment-variables">Upstart Intro, Cookbook and Best Practices</a>.</p>
<p>Con systemd, utilizzare la direttiva <code>Environment</code> nel file unit. Ad esempio:</p>
<pre>
<code class="language-sh" translate="no">
# /etc/systemd/system/myservice.service
Environment=NODE_ENV=production
</code>
</pre>
<p>Per ulteriori informazioni, consultare <a href="https://coreos.com/os/docs/latest/using-environment-variables-in-systemd-units.html">Using Environment Variables In systemd Units</a>.</p>
<p>Se si sta utilizzando StrongLoop Process Manager, è inoltre possibile <a href="https://docs.strongloop.com/display/SLC/Setting+up+a+production+host#Settingupaproductionhost-Setenvironmentvariables">impostare la variabile di ambiente quando si installa StrongLoop PM as a service</a>.</p>
<h3 id="verificare-che-lapplicazione-sia-in-grado-di-riavviarsi-automaticamente">Verificare che l’applicazione sia in grado di riavviarsi automaticamente</h3>
<p>In fase di produzione, l’applicazione non deve mai andare offline. Ciò significa che deve riavviarsi nel caso in cui sia l’applicazione che il server terminino in modo anomalo. Anche se ovviamente si spera che entrambe queste situazioni non si verifichino mai, realisticamente è necessario considerare l’eventualità di:</p>
<ul>
<li>Utilizzare un process manager per riavviare l’applicazione (e Node) quando termina in modo anomalo.</li>
<li>Utilizzare il sistema init fornito dal sistema operativo per riavviare il process manager quando il sistema operativo termina in modo anomalo. È inoltre possibile utilizzare il sistema init senza un process manager.</li>
</ul>
<p>Le applicazioni Node terminano in modo anomalo se riscontrano eccezioni non rilevate. La prima cosa da fare è verificare che l’applicazione sia stata verificata e che sia in grado di gestire tutte le eccezioni (consultare <a href="#exceptions">Gestire in modo appropriato le eccezioni</a> per dettagli). Come prevenzione, attivare un meccanismo che assicuri che applicazione si riavvii automaticamente in caso di arresto anomalo.</p>
<h4 id="utilizzare-un-process-manager">Utilizzare un process manager</h4>
<p>Nello sviluppo, l’applicazione è stata avviata semplicemente dalla riga comandi con <code>node server.js</code> o qualcosa di simile. Ma se si effettua questa stessa operazione in campo di produzione si andrà incontro a situazioni pericolose. Se l’applicazione termina in modo anomalo, sarà offline finché non viene riavviata. Per fare in modo che l’applicazione si riavvii nel caso in cui termini in modo anomalo, utilizzare un process manager. Un process manager è un “contenitore” per le applicazioni che facilita lo sviluppo, fornisce un’elevata disponibilità e consente di gestire l’applicazione al momento del runtime.</p>
<p>Oltre a fare in modo di riavviare l’applicazione in caso di arresto anomalo, un process manager consente di:</p>
<ul>
<li>Ottenere insight relativi alle prestazioni di runtime e al consumo delle risorse.</li>
<li>Modificare le impostazioni in modo dinamico per migliorare le prestazioni.</li>
<li>Controllare il processo di clustering (StrongLoop PM e pm2).</li>
</ul>
<p>I process manager più noti per Node sono i seguenti:</p>
<ul>
<li><a href="http://strong-pm.io/">StrongLoop Process Manager</a></li>
<li><a href="https://github.com/Unitech/pm2">PM2</a></li>
<li><a href="https://www.npmjs.com/package/forever">Forever</a></li>
</ul>
<p>Per un paragone a livello di funzioni dei tre process manager, consultare l’indirizzo <a href="http://strong-pm.io/compare/">http://strong-pm.io/compare/</a>. Per informazioni più dettagliate su tutti e tre i process manager, consultare <a href="/%7B%7B%20page.lang%20%7D%7D/advanced/pm.html">Process manager per le applicazioni Express</a>.</p>
<p>L’utilizzo di questi process manager sarà sufficiente per far restare attiva l’applicazione, anche se dovesse capitare che si arresti in modo anomalo.</p>
<p>Tuttavia, StrongLoop PM dispone di molte funzioni che sono indicate in modo specifico per l’implementazione della produzione. È possibile utilizzarle insieme ai relativi strumenti di StrongLoop per:</p>
<ul>
<li>Creare e confezionare l’applicazione localmente, quindi implementarla in modo sicuro al sistema di produzione.</li>
<li>Riavviare automaticamente l’applicazione se termina in modo anomalo per qualsiasi motivo.</li>
<li>Gestire i cluster in modo remoto.</li>
<li>Visualizzare i profili CPU e accumulare le istantanee per ottimizzare le prestazioni e diagnosticare le perdite di memoria.</li>
<li>Visualizzare le metriche delle prestazioni per l’applicazione.</li>
<li>Scalare facilmente a più host con un controllo integrato per il servizio di bilanciamento del carico Nginx.</li>
</ul>
<p>Come mostrato di seguito, quando si installa StrongLoop PM come servizio del sistema operativo utilizzando il sistema init, si riavvierà automaticamente quando si riavvia il sistema. Pertanto, consentirà ai processi delle applicazioni e ai cluster di restare sempre attivi.</p>
<h4 id="utilizzare-un-sistema-init">Utilizzare un sistema init</h4>
<p>Il successivo livello di affidabilità è quello di assicurare che l’applicazione venga riavviata quando si riavvia il server. I sistemi possono ancora arrestarsi per moltissimi motivi. Per fare in modo che l’applicazione si riavvii nel caso in cui un server si arresti in modo anomalo, utilizzare il sistema init integrato al sistema operativo. Oggi, i due sistemi init principali in uso sono <a href="https://wiki.debian.org/systemd">systemd</a> e <a href="http://upstart.ubuntu.com/">Upstart</a>.</p>
<p>Esistono due modi per utilizzare i sistemi init con l’applicazione Express:</p>
<ul>
<li>Far eseguire l’applicazione in un process manager e installare il process manager come servizio con il sistema init. Il process manager riavvierà l’applicazione nel caso in cui termini in modo anomalo e il sistema init riavvierà il process manager quando si riavvia il sistema operativo. Questa è la procedura consigliata.</li>
<li>Far eseguire l’applicazione (e Node) direttamente con il sistema init. Questa operazione risulta più semplice ma non si hanno gli stessi vantaggi dell’utilizzo di un process manager.</li>
</ul>
<h5 id="systemd">Systemd</h5>
<p>Systemd è un sistema Linux e un service manager. Le più importanti distribuzioni Linux hanno utilizzato systemd come sistema init predefinito.</p>
<p>Un file di configurazione del servizio systemd è denominato <em>unit file</em>, con un nome file che termina con .service. Segue un unit file di esempio per gestire un’applicazione Node direttamente (sostituire il testo in grassetto con i valori appropriati per il proprio sistema e applicazione):</p>
<pre>
<code class="language-sh" translate="no">
[Unit]
Description=Awesome Express App

[Service]
Type=simple
ExecStart=/usr/local/bin/node /projects/myapp/index.js
WorkingDirectory=/projects/myapp

User=nobody
Group=nogroup

# Environment variables:
Environment=NODE_ENV=production

# Allow many incoming connections
LimitNOFILE=infinity

# Allow core dumps for debugging
LimitCORE=infinity

StandardInput=null
StandardOutput=syslog
StandardError=syslog
Restart=always

[Install]
WantedBy=multi-user.target
</code>
</pre>
<p>Per ulteriori informazioni su systemd, consultare <a href="http://www.freedesktop.org/software/systemd/man/systemd.unit.html">systemd reference (man page)</a>.</p>
<h5 id="strongloop-pm-in-qualità-di-servizio-systemd">StrongLoop PM in qualità di servizio systemd</h5>
<p>È possibile installare facilmente StrongLoop Process Manager in qualità di servizio systemd. Dopo l’installazione, quando il server si riavvia, si riavvierà automaticamente StrongLoop PM, il quale riavvierà di conseguenza tutte le applicazioni che sta gestendo.</p>
<p>Per installare StrongLoop PM in qualità di servizio systemd:</p>
<pre>
<code class="language-sh" translate="no">
$ sudo sl-pm-install --systemd
</code>
</pre>
<p>Successivamente, avviare il servizio con:</p>
<pre>
<code class="language-sh" translate="no">
$ sudo /usr/bin/systemctl start strong-pm
</code>
</pre>
<p>Per ulteriori informazioni, consultare <a href="https://docs.strongloop.com/display/SLC/Setting+up+a+production+host#Settingupaproductionhost-RHEL7+,Ubuntu15.04or15.10">Configurazione di un host di produzione (documentazione StrongLoop)</a>.</p>
<h5 id="upstart">Upstart</h5>
<p>Upstart è uno strumento di sistema disponibile su molte distribuzioni Linux per l’avvio delle attività e dei servizi durante lo startup del sistema, per l’arresto delle stesse durante la fase di shutdown e per il controllo delle stesse. È possibile configurare l’applicazione Express o il process manager in qualità di servizio e successivamente Upstart le riavvierà automaticamente quando terminano in modo anomalo.</p>
<p>Un servizio Upstart è definito in un file di configurazione del lavoro (anche noto come “lavoro”) con un nome file che termina con <code>.conf</code>. Il seguente esempio mostra come creare un lavoro denominato “myapp” per un’applicazione denominata “myapp” con il file principale ubicato in <code>/projects/myapp/index.js</code>.</p>
<p>Creare un file denominato <code>myapp.conf</code> in <code>/etc/init/</code> con il seguente contenuto (sostituire il testo in grassetto con i valori appropriati per il proprio sistema e applicazione):</p>
<pre>
<code class="language-sh" translate="no">
# When to start the process
start on runlevel [2345]

# When to stop the process
stop on runlevel [016]

# Increase file descriptor limit to be able to handle more requests
limit nofile 50000 50000

# Use production mode
env NODE_ENV=production

# Run as www-data
setuid www-data
setgid www-data

# Run from inside the app dir
chdir /projects/myapp

# The process to start
exec /usr/local/bin/node /projects/myapp/index.js

# Restart the process if it is down
respawn

# Limit restart attempt to 10 times within 10 seconds
respawn limit 10 10
</code>
</pre>
<p>NOTA: questo script richiede Upstart 1.4 o versione successiva, supportato su Ubuntu 12.04-14.10.</p>
<p>Poiché il lavoro è configurato per essere eseguito quando si avvia il sistema, l’applicazione verrà avviata insieme al sistema operativo e riavviata automaticamente se l’applicazione termina in modo anomalo o se il sistema si arresta.</p>
<p>Oltre a riavviare automaticamente l’applicazione, Upstart consente di utilizzare i seguenti comandi:</p>
<ul>
<li><code>start myapp</code> – Avviare l’applicazione</li>
<li><code>restart myapp</code> – Riavviare l’applicazione</li>
<li><code>stop myapp</code> – Arrestare l’applicazione.</li>
</ul>
<p>Per ulteriori informazioni su Upstart, consultare <a href="http://upstart.ubuntu.com/cookbook">Upstart Intro, Cookbook and Best Practises</a>.</p>
<h5 id="strongloop-pm-in-qualità-di-servizio-upstart">StrongLoop PM in qualità di servizio Upstart</h5>
<p>È possibile installare facilmente StrongLoop Process Manager in qualità di servizio Upstart. Dopo l’installazione, quando il server si riavvia, si riavvierà automaticamente StrongLoop PM, il quale riavvierà di conseguenza tutte le applicazioni che sta gestendo.</p>
<p>Per installare StrongLoop PM in qualità di servizio Upstart 1.4:</p>
<pre>
<code class="language-sh" translate="no">
$ sudo sl-pm-install
</code>
</pre>
<p>Successivamente, eseguire il servizio con:</p>
<pre>
<code class="language-sh" translate="no">
$ sudo /sbin/initctl start strong-pm
</code>
</pre>
<p>NOTA: su sistemi che non supportano Upstart 1.4, i comandi sono leggermente differenti. Consultare <a href="https://docs.strongloop.com/display/SLC/Setting+up+a+production+host#Settingupaproductionhost-RHELLinux5and6,Ubuntu10.04-.10,11.04-.10">Configurazione di un host di produzione (documentazione StrongLoop)</a> per ulteriori informazioni.</p>
<h3 id="eseguire-lapplicazione-in-un-cluster">Eseguire l’applicazione in un cluster</h3>
<p>In un sistema multicore, è possibile aumentare le prestazioni di un’applicazione Node di molte volte avviando un cluster di processi. Un cluster esegue molte istanze di un’applicazione, nel caso ideale, un’istanza su ciascun core CPU, quindi, distribuendo il carico e le attività tra le istanze.</p>
<!--![Bilanciamento tra le istanze dell'applicazione utilizzando l'API del cluster](/images/clustering.png)-->
<p>IMPORTANTE: poiché le istanze dell’applicazione vengono eseguite come processi separati, non condividono lo stesso spazio di memoria. Ossia, gli oggetti sono locali rispetto a ciascuna istanza dell’applicazione. Pertanto, non è possibile conservare lo stato nel codice dell’applicazione. Tuttavia, è possibile utilizzare un datastore in-memory, ad esempio <a href="http://redis.io/">Redis</a> per memorizzare lo stato e i dati relativi alla sessione. Questa condizione si applica fondamentalmente a tutti i moduli di scaling orizzontale, se il processo di clustering viene effettuato con più processi o più server fisici.</p>
<p>Nelle applicazioni sottoposte a cluster, i processi di lavoro possono ternare in modo anomalo individualmente senza influenzare gli altri processi. Oltre ai vantaggi che si possono ottenere dalle prestazioni, l’isolamento dell’errore è un altro motivo che spinge a eseguire un cluster di processi di applicazioni. Quando un processo di lavoro termina in modo anomalo, ricordarsi sempre di registrare l’evento e di dare origine a un nuovo processo utilizzando cluster.fork().</p>
<h4 id="utilizzo-del-modulo-cluster-di-node">Utilizzo del modulo cluster di Node</h4>
<p>Il processo di clustering è stato reso possibile con il <a href="https://nodejs.org/docs/latest/api/cluster.html">cluster module</a> di Node. Ciò consente a un processo principale di dare origine a processi di lavoro e di distribuire le connessioni in entrata tra i processi di lavoro. Tuttavia, invece di utilizzare direttamente questo modulo, è meglio utilizzare uno dei molti strumenti disponibili che svolgono questa attività automaticamente; ad esempio <a href="https://www.npmjs.com/package/node-pm">node-pm</a> o <a href="https://www.npmjs.com/package/cluster-service">cluster-service</a>.</p>
<h4 id="utilizzo-di-strongloop-pm">Utilizzo di StrongLoop PM</h4>
<p>Se si implementa l’applicazione a StrongLoop Process Manager (PM), è possibile sfruttare i vantaggi del processo di clustering <em>senza</em> dover modificare il codice dell’applicazione.</p>
<p>Quando StrongLoop Process Manager (PM) esegue un’applicazione, la esegue automaticamente in un cluster con un numero di processi di lavoro equivalente al numero di core CPU presenti sul sistema. È possibile modificare manualmente il numero di processi di lavoro nel cluster utilizzando lo strumento della riga comandi senza arrestare l’applicazione.</p>
<p>Ad esempio, se l’applicazione è stata implementata su prod.foo.com e StrongLoop PM è in ascolto sulla porta 8701 (quella predefinita), per impostare la dimensione del cluster a otto utilizzando slc:</p>
<pre>
<code class="language-sh" translate="no">
$ slc ctl -C http://prod.foo.com:8701 set-size my-app 8
</code>
</pre>
<p>Per ulteriori informazioni sul processo di clustering con StrongLoop PM, consultare <a href="https://docs.strongloop.com/display/SLC/Clustering">Processo di clustering</a> nella documentazione StrongLoop.</p>
<h3 id="memorizzare-in-cache-i-risultati-della-richiesta">Memorizzare in cache i risultati della richiesta</h3>
<p>Un’altra strategia per migliorare le prestazioni in fase di produzione è quella di memorizzare in cache i risultati delle richieste, in modo tale che l’applicazione non debba gestire nuovamente la stessa richiesta.</p>
<p>Utilizzare un server di memorizzazione in cache quale <a href="https://www.varnish-cache.org/">Varnish</a> o <a href="https://www.nginx.com/resources/wiki/start/topics/examples/reverseproxycachingexample/">Nginx</a> (vedere anche <a href="https://serversforhackers.com/nginx-caching/">Nginx Caching</a>) per migliorare notevolmente la velocità e le prestazioni dell’applicazione.</p>
<h3 id="utilizzare-un-servizio-di-bilanciamento-del-carico">Utilizzare un servizio di bilanciamento del carico</h3>
<p>A prescindere da quanto sia ottimizzata un’applicazione, una singola istanza è in grado di gestire solo una quantità limitata di carico e traffico. Un modo per scalare un’applicazione è quello di eseguire più delle proprie istanze e distribuire il traffico tramite un servizio di bilanciamento del carico. L’impostazione di un servizio di bilanciamento del carico può migliorare la velocità e le prestazioni dell’applicazione e abilitarla a scalare di più di quanto sia possibile fare con una singola istanza.</p>
<p>Un servizio di bilanciamento del carico è solitamente un proxy inverso che gestisce il traffico a e d più istanze di applicazione e server. È possibile impostare facilmente un servizio di bilanciamento del carico per l’applicazione utilizzando <a href="http://nginx.org/en/docs/http/load_balancing.html">Nginx</a> or <a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-haproxy-and-load-balancing-concepts">HAProxy</a>.</p>
<p>Con il servizio di bilanciamento del carico, è possibile che sia necessario garantire che le richieste associate a un ID sessione particolare si connettano al processo che le ha originate. Questo processo è noto come <em>affinità sessione</em> o <em>sessioni delicate</em>. Si consiglia di utilizzare un data store, ad esempio Redis, per i dati sessione (a seconda dell’applicazione). Per informazioni, consultare <a href="http://socket.io/docs/using-multiple-nodes/">Utilizzo di più nodi</a>.</p>
<h4 id="utilizzo-di-strongloop-pm-con-un-servizio-di-bilanciamento-del-carico-nginx">Utilizzo di StrongLoop PM con un servizio di bilanciamento del carico Nginx</h4>
<p><a href="http://strong-pm.io/">StrongLoop Process Manager</a> si integra con un controller Nginx, rendendo semplice il processo di configurazione di ambienti di produzione multi host. Per ulteriori informazioni, consultare <a href="https://docs.strongloop.com/display/SLC/Scaling+to+multiple+servers">Processo di scaling su più server</a> (documentazione StrongLoop). <a name="proxy"></a></p>
<h3 id="utilizzare-un-proxy-inverso">Utilizzare un proxy inverso</h3>
<p>Un proxy inverso si trova davanti a un’applicazione web ed esegue le operazioni di supporto sulle richieste, oltre a indirizzare le richieste all’applicazione. Inoltre, è in grado di gestire pagine di errore, compressioni, memorizzazioni in cache e il bilanciamento del carico.</p>
<p>Le attività di gestione che non richiedono la conoscenza dello stato dell’applicazione per un proxy inverso consentono ad Express di eseguire attività dell’applicazione specializzate. Per questo motivo, si consiglia di eseguire Express dietro un proxy inverso come <a href="https://www.nginx.com/">Nginx</a> o <a href="http://www.haproxy.org/">HAProxy</a> in fase di produzione.</p>
</body>
</html>
